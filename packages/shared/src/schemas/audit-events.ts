/**
 * Zod schemas for audit events
 * Follows Rexera's pattern of using Zod for validation
 */

import { z } from 'zod';
import { 
  AUDIT_ACTOR_TYPES, 
  AUDIT_ACTIONS, 
  AUDIT_EVENT_TYPES, 
  AUDIT_RESOURCE_TYPES 
} from '../enums/index.js';

// =====================================================
// BASE AUDIT EVENT SCHEMA
// =====================================================

/**
 * Core audit event schema matching the database structure
 */
export const AuditEventSchema = z.object({
  id: z.string().uuid().optional(), // Generated by database
  actor_type: z.enum(AUDIT_ACTOR_TYPES),
  actor_id: z.string().min(1, 'Actor ID is required'),
  actor_name: z.string().optional(),
  event_type: z.enum(AUDIT_EVENT_TYPES),
  action: z.enum(AUDIT_ACTIONS),
  resource_type: z.enum(AUDIT_RESOURCE_TYPES),
  resource_id: z.string().uuid('Resource ID must be a valid UUID'),
  workflow_id: z.string().uuid().optional(),
  client_id: z.string().uuid().optional(),
  event_data: z.record(z.any()).default({}),
  created_at: z.string().datetime().optional(), // Generated by database
});

/**
 * Schema for creating new audit events (without auto-generated fields)
 */
export const CreateAuditEventSchema = AuditEventSchema.omit({
  id: true,
  created_at: true,
});

/**
 * Schema for API requests to fetch audit events with filters
 */
export const AuditEventQuerySchema = z.object({
  workflow_id: z.string().uuid().optional(),
  client_id: z.string().uuid().optional(),
  actor_type: z.enum(AUDIT_ACTOR_TYPES).optional(),
  actor_id: z.string().optional(),
  event_type: z.enum(AUDIT_EVENT_TYPES).optional(),
  action: z.enum(AUDIT_ACTIONS).optional(),
  resource_type: z.enum(AUDIT_RESOURCE_TYPES).optional(),
  resource_id: z.string().uuid().optional(),
  from_date: z.string().datetime().optional(),
  to_date: z.string().datetime().optional(),
  limit: z.number().int().min(1).max(100).default(50),
  offset: z.number().int().min(0).default(0),
});

// =====================================================
// SPECIALIZED AUDIT EVENT SCHEMAS
// =====================================================

/**
 * Schema for workflow-related audit events
 */
export const WorkflowAuditEventSchema = CreateAuditEventSchema.extend({
  event_type: z.literal('workflow_management'),
  resource_type: z.literal('workflow'),
  workflow_id: z.string().uuid(), // Required for workflow events
  event_data: z.object({
    field_changed: z.string().optional(),
    old_value: z.any().optional(),
    new_value: z.any().optional(),
    reason: z.string().optional(),
    user_agent: z.string().optional(),
  }).optional(),
});

/**
 * Schema for task execution audit events
 */
export const TaskAuditEventSchema = CreateAuditEventSchema.extend({
  event_type: z.enum(['task_execution', 'task_intervention']),
  resource_type: z.literal('task_execution'),
  workflow_id: z.string().uuid(), // Required for task events
  event_data: z.object({
    task_title: z.string().optional(),
    task_type: z.string().optional(),
    execution_status: z.string().optional(),
    execution_source: z.string().optional(),
    output_size: z.number().optional(),
    comment: z.string().optional(),
    browser: z.string().optional(),
    intervention_source: z.string().optional(),
  }).optional(),
});

/**
 * Schema for SLA-related audit events
 */
export const SlaAuditEventSchema = CreateAuditEventSchema.extend({
  event_type: z.literal('sla_management'),
  event_data: z.object({
    field_changed: z.literal('sla_status').optional(),
    old_value: z.enum(['ON_TIME', 'AT_RISK', 'BREACHED']).optional(),
    new_value: z.enum(['ON_TIME', 'AT_RISK', 'BREACHED']).optional(),
    hours_overdue: z.number().optional(),
    sla_hours: z.number().optional(),
    automated_action: z.boolean().optional(),
    notifications_sent: z.number().optional(),
  }).optional(),
});

/**
 * Schema for user authentication audit events
 */
export const AuthAuditEventSchema = CreateAuditEventSchema.extend({
  event_type: z.literal('user_authentication'),
  resource_type: z.literal('user_profile'),
  action: z.enum(['login', 'logout']),
  event_data: z.object({
    user_agent: z.string().optional(),
    ip_address: z.string().optional(),
    session_id: z.string().optional(),
    login_method: z.string().optional(),
  }).optional(),
});

// =====================================================
// TYPE EXPORTS
// =====================================================

export type AuditEvent = z.infer<typeof AuditEventSchema>;
export type CreateAuditEvent = z.infer<typeof CreateAuditEventSchema>;
export type AuditEventQuery = z.infer<typeof AuditEventQuerySchema>;
export type WorkflowAuditEvent = z.infer<typeof WorkflowAuditEventSchema>;
export type TaskAuditEvent = z.infer<typeof TaskAuditEventSchema>;
export type SlaAuditEvent = z.infer<typeof SlaAuditEventSchema>;
export type AuthAuditEvent = z.infer<typeof AuthAuditEventSchema>;